"""Generator Agent - Worker agent for data generation."""

import logging
from typing import List, Dict, Any, Optional

from app.agents.base_agent import BaseAgent
from app.models.schema import DataSchema
from app.utils.llm_client import LLMClient
from app.tools.deduplication import DeduplicationTool
from app.core.config import settings

logger = logging.getLogger(__name__)


class GeneratorAgent(BaseAgent):
    """
    Generator Agent - specialized worker for synthetic data generation.

    Each instance acts as an independent worker that:
    1. Receives a schema and row count
    2. Calls the LLM to generate data
    3. Validates the generated data
    4. Applies deduplication
    5. Returns unique, high-quality results
    """

    def __init__(
        self,
        schema: DataSchema,
        dedup_tool: DeduplicationTool,
        collection_name: str,
        dedup_threshold: float = None,
        agent_id: str = None,
    ):
        """
        Initialize Generator Agent.

        Args:
            schema: Data schema to generate from
            dedup_tool: Deduplication tool instance
            collection_name: ChromaDB collection name
            dedup_threshold: Similarity threshold for deduplication
            agent_id: Unique agent identifier
        """
        super().__init__(agent_id)
        self.schema = schema
        self.dedup_tool = dedup_tool
        self.collection_name = collection_name
        self.dedup_threshold = dedup_threshold or settings.DEDUPLICATION_THRESHOLD
        self.llm_client = LLMClient()
        self.deduplicated_count = 0

    async def generate_data(self, row_count: int) -> List[Dict[str, Any]]:
        """
        Generate synthetic data.

        Args:
            row_count: Number of rows to generate

        Returns:
            List of generated data rows
        """
        try:
            await self.pre_execute()

            self.logger.info(f"Generating {row_count} rows with schema")

            # Build prompts
            system_prompt = self._build_system_prompt()
            user_prompt = self._build_user_prompt(row_count)

            # Generate data with structured output
            response = await self.llm_client.generate_structured_output(
                system_prompt=system_prompt,
                user_prompt=user_prompt,
                schema=self._get_output_schema(),
                model=settings.GENERATION_MODEL,
            )

            # Extract rows
            raw_rows = response.get("data", [])

            if not raw_rows:
                self.logger.warning("No data generated by LLM")
                return []

            self.logger.info(f"LLM generated {len(raw_rows)} rows")

            # Apply deduplication
            unique_rows = await self._deduplicate_rows(raw_rows)

            self.logger.info(
                f"After deduplication: {len(unique_rows)} unique rows "
                f"({self.deduplicated_count} duplicates removed)"
            )

            await self.post_execute(unique_rows)

            return unique_rows

        except Exception as e:
            await self.on_error(e)
            raise

    async def _deduplicate_rows(
        self, rows: List[Dict[str, Any]]
    ) -> List[Dict[str, Any]]:
        """
        Apply deduplication to generated rows.

        Args:
            rows: Raw generated rows

        Returns:
            Deduplicated rows
        """
        try:
            unique_rows = []
            batch_size = 100  # Process in batches

            for i in range(0, len(rows), batch_size):
                batch = rows[i : i + batch_size]

                # Check for duplicates using vector similarity
                is_duplicate_flags = await self.dedup_tool.check_duplicates(
                    rows=batch,
                    collection_name=self.collection_name,
                    threshold=self.dedup_threshold,
                )

                # Filter out duplicates
                for row, is_duplicate in zip(batch, is_duplicate_flags):
                    if not is_duplicate:
                        unique_rows.append(row)
                    else:
                        self.deduplicated_count += 1

                # Add unique rows to vector store
                unique_batch = [
                    row
                    for row, is_dup in zip(batch, is_duplicate_flags)
                    if not is_dup
                ]

                if unique_batch:
                    await self.dedup_tool.add_to_store(
                        rows=unique_batch, collection_name=self.collection_name
                    )

            return unique_rows

        except Exception as e:
            self.logger.error(f"Deduplication error: {str(e)}", exc_info=True)
            # Return raw rows if deduplication fails
            return rows

    def _build_system_prompt(self) -> str:
        """Build system prompt for data generation."""
        return f"""You are a synthetic data generator. Generate realistic, diverse, and 
high-quality data according to the provided schema.

Schema:
{self._format_schema_for_prompt()}

Requirements:
- Generate EXACTLY the requested number of rows
- Ensure data is realistic and follows the schema constraints
- Vary the data to create diversity (no repetitive patterns)
- Follow all type specifications and constraints
- Return data as a JSON array under the "data" key

Return format:
{{
  "data": [
    {{"column1": "value1", "column2": "value2", ...}},
    ...
  ]
}}"""

    def _build_user_prompt(self, row_count: int) -> str:
        """Build user prompt for data generation."""
        return f"Generate exactly {row_count} rows of synthetic data following the schema."

    def _format_schema_for_prompt(self) -> str:
        """Format schema for LLM prompt."""
        schema_lines = []
        for col in self.schema.columns:
            line = f"- {col.name} ({col.type.value}): {col.description}"
            if col.constraints:
                line += f" [constraints: {col.constraints}]"
            if col.examples:
                line += f" [examples: {', '.join(col.examples[:3])}]"
            schema_lines.append(line)

        return "\n".join(schema_lines)

    def _get_output_schema(self) -> dict:
        """Get JSON schema for structured output."""
        # Build properties based on schema columns
        properties = {}
        for col in self.schema.columns:
            col_schema = self._get_column_json_schema(col)
            properties[col.name] = col_schema

        return {
            "type": "object",
            "properties": {
                "data": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "properties": properties,
                        "required": [col.name for col in self.schema.columns],
                    },
                }
            },
            "required": ["data"],
        }

    def _get_column_json_schema(self, col) -> dict:
        """Get JSON schema for a single column."""
        type_mapping = {
            "string": {"type": "string"},
            "integer": {"type": "integer"},
            "float": {"type": "number"},
            "boolean": {"type": "boolean"},
            "datetime": {"type": "string", "format": "date-time"},
            "date": {"type": "string", "format": "date"},
            "email": {"type": "string", "format": "email"},
            "url": {"type": "string", "format": "uri"},
            "uuid": {"type": "string", "format": "uuid"},
            "phone": {"type": "string"},
            "json": {"type": "object"},
        }

        schema = type_mapping.get(col.type.value, {"type": "string"})

        # Add constraints if present
        if col.constraints:
            if "min" in col.constraints:
                schema["minimum"] = col.constraints["min"]
            if "max" in col.constraints:
                schema["maximum"] = col.constraints["max"]
            if "pattern" in col.constraints:
                schema["pattern"] = col.constraints["pattern"]

        return schema

    async def execute(self, row_count: int) -> List[Dict[str, Any]]:
        """Execute agent (implements BaseAgent.execute)."""
        return await self.generate_data(row_count)
